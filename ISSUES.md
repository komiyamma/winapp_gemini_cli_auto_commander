# GeminiCLIAutoCommander の問題点

このドキュメントは `GeminiCLIAutoCommander` プロジェクトの潜在的な問題点をまとめたものです。

## 1. 設定の堅牢性の欠如

設定ファイル `GeminiCLIAutoCommander.config` の取り扱いには、以下の問題があります。

- **エラーの隠蔽**: 設定ファイルの読み込み処理 (`GeminiConstants.cs`) では、`try-catch` ブロックですべての例外が握りつぶされています。このため、設定ファイルが存在しない、XMLの形式が正しくない、あるいはアクセス権がないといった問題が発生しても、プログラムはエラーを報告せずに続行します。結果として、空の設定値が使われ、後続の処理が予期せぬ形で失敗する原因となります。
- **必須項目の検証不足**: `GeminiModel` や `GeminiPrompt` のような、プログラムの動作に必須の設定項目がファイル内に存在するかどうかのチェックが行われません。これらの値が設定されていない場合、空文字列として扱われ、`gemini.cmd` への無効な引数として渡されてしまい、エラーとなります。起動時に必須項目を検証し、不足している場合は具体的なエラーメッセージを出して終了するべきです。

## 2. 実行ファイル探索の柔軟性の欠如

`gemini.cmd` の実行パスを解決する処理 (`GeminiPathResolver.cs`) には、以下の問題があります。

- **探索パスの限定**: `npm` のグローバルインストールパス (`npm config get prefix`) と、特定のユーザーフォルダ (`%APPDATA%\npm`) のみを探索対象としています。しかし、システムの環境変数 `PATH` は探索されません。これにより、ユーザーが `gemini.cmd` を異なる方法でインストールしたり、カスタムの場所に配置したりした場合に、プログラムは実行ファイルを見つけることができません。
- **エラー通知の不足**: `npm config get prefix` コマンドの実行に失敗した場合も、例外が握りつぶされるため、ユーザーに問題が通知されません。`npm` がインストールされていない、PATHが通っていない等の状況が分かりにくくなっています。

## 3. ユーザーフィードバックの不足

プログラムが失敗した際に、ユーザーが原因を特定するための情報が十分に提供されていません。

- `gemini.cmd` が見つからない場合、「`gemini.cmd` が見つかりませんでした。」というメッセージしか表示されず、プログラムがどこを探しに行ったのか、どうすれば解決できるのか（例：「npmでグローバルインストールしてください」など）といった具体的な情報がありません。
- 設定の読み込みに失敗した場合も同様に、どの設定が問題であったかの情報がユーザーに伝わりません。

## 4. 引数のハードコーディング

`gemini.cmd` へ渡すコマンドライン引数が、ソースコード (`Program.cs`) 内に `-m`, `-y`, `-p` とハードコーディングされています。

- これにより、`gemini.cmd` がサポートする他のオプション（例えば、温度設定のための `--temperature` など）を利用したい場合に、ソースコードの変更が必要になってしまいます。
- このようなラッパープログラムでは、自身の引数を透過的に子プロセスに渡す設計にすることで、より高い柔軟性を提供できます。

## 5. プラットフォームへの強い依存

子プロセス (`gemini.cmd`) のクリーンアップを確実に行うため、Windows固有の「Job Object」機能を利用しています (`JobObjects.cs`)。

- この実装は堅牢である一方、プログラムがWindows環境でしか動作しないことを意味します。
- 将来的にLinuxやmacOSなど、他のプラットフォームへの対応を視野に入れる場合、この部分はクロスプラットフォームで動作する別の仕組みに置き換える必要があります。
